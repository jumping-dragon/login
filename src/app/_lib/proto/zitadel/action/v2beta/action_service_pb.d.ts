// @generated by protoc-gen-es v2.6.0 with parameter "json_types=true,import_extension=js"
// @generated from file zitadel/action/v2beta/action_service.proto (package zitadel.action.v2beta, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { RESTAsync, RESTAsyncJson, RESTCall, RESTCallJson, RESTWebhook, RESTWebhookJson, Target, TargetJson } from "./target_pb.js";
import type { Duration, DurationJson, Timestamp, TimestampJson } from "@bufbuild/protobuf/wkt";
import type { PaginationRequest, PaginationRequestJson, PaginationResponse, PaginationResponseJson } from "../../filter/v2beta/filter_pb.js";
import type { ExecutionFieldName, ExecutionFieldNameJson, ExecutionSearchFilter, ExecutionSearchFilterJson, TargetFieldName, TargetFieldNameJson, TargetSearchFilter, TargetSearchFilterJson } from "./query_pb.js";
import type { Condition, ConditionJson, Execution, ExecutionJson } from "./execution_pb.js";

/**
 * Describes the file zitadel/action/v2beta/action_service.proto.
 */
export declare const file_zitadel_action_v2beta_action_service: GenFile;

/**
 * @generated from message zitadel.action.v2beta.CreateTargetRequest
 */
export declare type CreateTargetRequest = Message<"zitadel.action.v2beta.CreateTargetRequest"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Defines the target type and how the response of the target is treated.
   *
   * @generated from oneof zitadel.action.v2beta.CreateTargetRequest.target_type
   */
  targetType: {
    /**
     * Wait for response but response body is ignored, status is checked, call is sent as post.
     *
     * @generated from field: zitadel.action.v2beta.RESTWebhook rest_webhook = 2;
     */
    value: RESTWebhook;
    case: "restWebhook";
  } | {
    /**
     * Wait for response and response body is used, status is checked, call is sent as post.
     *
     * @generated from field: zitadel.action.v2beta.RESTCall rest_call = 3;
     */
    value: RESTCall;
    case: "restCall";
  } | {
    /**
     * Call is executed in parallel to others, ZITADEL does not wait until the call is finished. The state is ignored, call is sent as post.
     *
     * @generated from field: zitadel.action.v2beta.RESTAsync rest_async = 4;
     */
    value: RESTAsync;
    case: "restAsync";
  } | { case: undefined; value?: undefined };

  /**
   * Timeout defines the duration until ZITADEL cancels the execution.
   * If the target doesn't respond before this timeout expires, then the connection is closed and the action fails. Depending on the target type and possible setting on `interrupt_on_error` following targets will not be called. In case of a `rest_async` target only this specific target will fail, without any influence on other targets of the same execution.
   *
   * @generated from field: google.protobuf.Duration timeout = 5;
   */
  timeout?: Duration;

  /**
   * @generated from field: string endpoint = 6;
   */
  endpoint: string;
};

/**
 * @generated from message zitadel.action.v2beta.CreateTargetRequest
 */
export declare type CreateTargetRequestJson = {
  /**
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * Wait for response but response body is ignored, status is checked, call is sent as post.
   *
   * @generated from field: zitadel.action.v2beta.RESTWebhook rest_webhook = 2;
   */
  restWebhook?: RESTWebhookJson;

  /**
   * Wait for response and response body is used, status is checked, call is sent as post.
   *
   * @generated from field: zitadel.action.v2beta.RESTCall rest_call = 3;
   */
  restCall?: RESTCallJson;

  /**
   * Call is executed in parallel to others, ZITADEL does not wait until the call is finished. The state is ignored, call is sent as post.
   *
   * @generated from field: zitadel.action.v2beta.RESTAsync rest_async = 4;
   */
  restAsync?: RESTAsyncJson;

  /**
   * Timeout defines the duration until ZITADEL cancels the execution.
   * If the target doesn't respond before this timeout expires, then the connection is closed and the action fails. Depending on the target type and possible setting on `interrupt_on_error` following targets will not be called. In case of a `rest_async` target only this specific target will fail, without any influence on other targets of the same execution.
   *
   * @generated from field: google.protobuf.Duration timeout = 5;
   */
  timeout?: DurationJson;

  /**
   * @generated from field: string endpoint = 6;
   */
  endpoint?: string;
};

/**
 * Describes the message zitadel.action.v2beta.CreateTargetRequest.
 * Use `create(CreateTargetRequestSchema)` to create a new message.
 */
export declare const CreateTargetRequestSchema: GenMessage<CreateTargetRequest, {jsonType: CreateTargetRequestJson}>;

/**
 * @generated from message zitadel.action.v2beta.CreateTargetResponse
 */
export declare type CreateTargetResponse = Message<"zitadel.action.v2beta.CreateTargetResponse"> & {
  /**
   * The unique identifier of the newly created target.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The timestamp of the target creation.
   *
   * @generated from field: google.protobuf.Timestamp creation_date = 2;
   */
  creationDate?: Timestamp;

  /**
   * Key used to sign and check payload sent to the target.
   *
   * @generated from field: string signing_key = 3;
   */
  signingKey: string;
};

/**
 * @generated from message zitadel.action.v2beta.CreateTargetResponse
 */
export declare type CreateTargetResponseJson = {
  /**
   * The unique identifier of the newly created target.
   *
   * @generated from field: string id = 1;
   */
  id?: string;

  /**
   * The timestamp of the target creation.
   *
   * @generated from field: google.protobuf.Timestamp creation_date = 2;
   */
  creationDate?: TimestampJson;

  /**
   * Key used to sign and check payload sent to the target.
   *
   * @generated from field: string signing_key = 3;
   */
  signingKey?: string;
};

/**
 * Describes the message zitadel.action.v2beta.CreateTargetResponse.
 * Use `create(CreateTargetResponseSchema)` to create a new message.
 */
export declare const CreateTargetResponseSchema: GenMessage<CreateTargetResponse, {jsonType: CreateTargetResponseJson}>;

/**
 * @generated from message zitadel.action.v2beta.UpdateTargetRequest
 */
export declare type UpdateTargetRequest = Message<"zitadel.action.v2beta.UpdateTargetRequest"> & {
  /**
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * @generated from field: optional string name = 2;
   */
  name?: string;

  /**
   * Defines the target type and how the response of the target is treated.
   *
   * @generated from oneof zitadel.action.v2beta.UpdateTargetRequest.target_type
   */
  targetType: {
    /**
     * Wait for response but response body is ignored, status is checked, call is sent as post.
     *
     * @generated from field: zitadel.action.v2beta.RESTWebhook rest_webhook = 3;
     */
    value: RESTWebhook;
    case: "restWebhook";
  } | {
    /**
     * Wait for response and response body is used, status is checked, call is sent as post.
     *
     * @generated from field: zitadel.action.v2beta.RESTCall rest_call = 4;
     */
    value: RESTCall;
    case: "restCall";
  } | {
    /**
     * Call is executed in parallel to others, ZITADEL does not wait until the call is finished. The state is ignored, call is sent as post.
     *
     * @generated from field: zitadel.action.v2beta.RESTAsync rest_async = 5;
     */
    value: RESTAsync;
    case: "restAsync";
  } | { case: undefined; value?: undefined };

  /**
   * Timeout defines the duration until ZITADEL cancels the execution.
   * If the target doesn't respond before this timeout expires, then the connection is closed and the action fails. Depending on the target type and possible setting on `interrupt_on_error` following targets will not be called. In case of a `rest_async` target only this specific target will fail, without any influence on other targets of the same execution.
   *
   * @generated from field: optional google.protobuf.Duration timeout = 6;
   */
  timeout?: Duration;

  /**
   * @generated from field: optional string endpoint = 7;
   */
  endpoint?: string;

  /**
   * Regenerate the key used for signing and checking the payload sent to the target.
   * Set the graceful period for the existing key. During that time, the previous
   * signing key and the new one will be used to sign the request to allow you a smooth
   * transition onf your API.
   *
   * Note that we currently only allow an immediate rotation ("0s") and will support
   * longer expirations in the future.
   *
   * @generated from field: optional google.protobuf.Duration expiration_signing_key = 8;
   */
  expirationSigningKey?: Duration;
};

/**
 * @generated from message zitadel.action.v2beta.UpdateTargetRequest
 */
export declare type UpdateTargetRequestJson = {
  /**
   * @generated from field: string id = 1;
   */
  id?: string;

  /**
   * @generated from field: optional string name = 2;
   */
  name?: string;

  /**
   * Wait for response but response body is ignored, status is checked, call is sent as post.
   *
   * @generated from field: zitadel.action.v2beta.RESTWebhook rest_webhook = 3;
   */
  restWebhook?: RESTWebhookJson;

  /**
   * Wait for response and response body is used, status is checked, call is sent as post.
   *
   * @generated from field: zitadel.action.v2beta.RESTCall rest_call = 4;
   */
  restCall?: RESTCallJson;

  /**
   * Call is executed in parallel to others, ZITADEL does not wait until the call is finished. The state is ignored, call is sent as post.
   *
   * @generated from field: zitadel.action.v2beta.RESTAsync rest_async = 5;
   */
  restAsync?: RESTAsyncJson;

  /**
   * Timeout defines the duration until ZITADEL cancels the execution.
   * If the target doesn't respond before this timeout expires, then the connection is closed and the action fails. Depending on the target type and possible setting on `interrupt_on_error` following targets will not be called. In case of a `rest_async` target only this specific target will fail, without any influence on other targets of the same execution.
   *
   * @generated from field: optional google.protobuf.Duration timeout = 6;
   */
  timeout?: DurationJson;

  /**
   * @generated from field: optional string endpoint = 7;
   */
  endpoint?: string;

  /**
   * Regenerate the key used for signing and checking the payload sent to the target.
   * Set the graceful period for the existing key. During that time, the previous
   * signing key and the new one will be used to sign the request to allow you a smooth
   * transition onf your API.
   *
   * Note that we currently only allow an immediate rotation ("0s") and will support
   * longer expirations in the future.
   *
   * @generated from field: optional google.protobuf.Duration expiration_signing_key = 8;
   */
  expirationSigningKey?: DurationJson;
};

/**
 * Describes the message zitadel.action.v2beta.UpdateTargetRequest.
 * Use `create(UpdateTargetRequestSchema)` to create a new message.
 */
export declare const UpdateTargetRequestSchema: GenMessage<UpdateTargetRequest, {jsonType: UpdateTargetRequestJson}>;

/**
 * @generated from message zitadel.action.v2beta.UpdateTargetResponse
 */
export declare type UpdateTargetResponse = Message<"zitadel.action.v2beta.UpdateTargetResponse"> & {
  /**
   * The timestamp of the change of the target.
   *
   * @generated from field: google.protobuf.Timestamp change_date = 1;
   */
  changeDate?: Timestamp;

  /**
   * Key used to sign and check payload sent to the target.
   *
   * @generated from field: optional string signing_key = 2;
   */
  signingKey?: string;
};

/**
 * @generated from message zitadel.action.v2beta.UpdateTargetResponse
 */
export declare type UpdateTargetResponseJson = {
  /**
   * The timestamp of the change of the target.
   *
   * @generated from field: google.protobuf.Timestamp change_date = 1;
   */
  changeDate?: TimestampJson;

  /**
   * Key used to sign and check payload sent to the target.
   *
   * @generated from field: optional string signing_key = 2;
   */
  signingKey?: string;
};

/**
 * Describes the message zitadel.action.v2beta.UpdateTargetResponse.
 * Use `create(UpdateTargetResponseSchema)` to create a new message.
 */
export declare const UpdateTargetResponseSchema: GenMessage<UpdateTargetResponse, {jsonType: UpdateTargetResponseJson}>;

/**
 * @generated from message zitadel.action.v2beta.DeleteTargetRequest
 */
export declare type DeleteTargetRequest = Message<"zitadel.action.v2beta.DeleteTargetRequest"> & {
  /**
   * @generated from field: string id = 1;
   */
  id: string;
};

/**
 * @generated from message zitadel.action.v2beta.DeleteTargetRequest
 */
export declare type DeleteTargetRequestJson = {
  /**
   * @generated from field: string id = 1;
   */
  id?: string;
};

/**
 * Describes the message zitadel.action.v2beta.DeleteTargetRequest.
 * Use `create(DeleteTargetRequestSchema)` to create a new message.
 */
export declare const DeleteTargetRequestSchema: GenMessage<DeleteTargetRequest, {jsonType: DeleteTargetRequestJson}>;

/**
 * @generated from message zitadel.action.v2beta.DeleteTargetResponse
 */
export declare type DeleteTargetResponse = Message<"zitadel.action.v2beta.DeleteTargetResponse"> & {
  /**
   * The timestamp of the deletion of the target.
   * Note that the deletion date is only guaranteed to be set if the deletion was successful during the request.
   * In case the deletion occurred in a previous request, the deletion date might be empty.
   *
   * @generated from field: google.protobuf.Timestamp deletion_date = 3;
   */
  deletionDate?: Timestamp;
};

/**
 * @generated from message zitadel.action.v2beta.DeleteTargetResponse
 */
export declare type DeleteTargetResponseJson = {
  /**
   * The timestamp of the deletion of the target.
   * Note that the deletion date is only guaranteed to be set if the deletion was successful during the request.
   * In case the deletion occurred in a previous request, the deletion date might be empty.
   *
   * @generated from field: google.protobuf.Timestamp deletion_date = 3;
   */
  deletionDate?: TimestampJson;
};

/**
 * Describes the message zitadel.action.v2beta.DeleteTargetResponse.
 * Use `create(DeleteTargetResponseSchema)` to create a new message.
 */
export declare const DeleteTargetResponseSchema: GenMessage<DeleteTargetResponse, {jsonType: DeleteTargetResponseJson}>;

/**
 * @generated from message zitadel.action.v2beta.GetTargetRequest
 */
export declare type GetTargetRequest = Message<"zitadel.action.v2beta.GetTargetRequest"> & {
  /**
   * @generated from field: string id = 1;
   */
  id: string;
};

/**
 * @generated from message zitadel.action.v2beta.GetTargetRequest
 */
export declare type GetTargetRequestJson = {
  /**
   * @generated from field: string id = 1;
   */
  id?: string;
};

/**
 * Describes the message zitadel.action.v2beta.GetTargetRequest.
 * Use `create(GetTargetRequestSchema)` to create a new message.
 */
export declare const GetTargetRequestSchema: GenMessage<GetTargetRequest, {jsonType: GetTargetRequestJson}>;

/**
 * @generated from message zitadel.action.v2beta.GetTargetResponse
 */
export declare type GetTargetResponse = Message<"zitadel.action.v2beta.GetTargetResponse"> & {
  /**
   * @generated from field: zitadel.action.v2beta.Target target = 1;
   */
  target?: Target;
};

/**
 * @generated from message zitadel.action.v2beta.GetTargetResponse
 */
export declare type GetTargetResponseJson = {
  /**
   * @generated from field: zitadel.action.v2beta.Target target = 1;
   */
  target?: TargetJson;
};

/**
 * Describes the message zitadel.action.v2beta.GetTargetResponse.
 * Use `create(GetTargetResponseSchema)` to create a new message.
 */
export declare const GetTargetResponseSchema: GenMessage<GetTargetResponse, {jsonType: GetTargetResponseJson}>;

/**
 * @generated from message zitadel.action.v2beta.ListTargetsRequest
 */
export declare type ListTargetsRequest = Message<"zitadel.action.v2beta.ListTargetsRequest"> & {
  /**
   * List limitations and ordering.
   *
   * @generated from field: optional zitadel.filter.v2beta.PaginationRequest pagination = 1;
   */
  pagination?: PaginationRequest;

  /**
   * The field the result is sorted by. The default is the creation date. Beware that if you change this, your result pagination might be inconsistent.
   *
   * @generated from field: optional zitadel.action.v2beta.TargetFieldName sorting_column = 2;
   */
  sortingColumn?: TargetFieldName;

  /**
   * Define the criteria to query for.
   *
   * @generated from field: repeated zitadel.action.v2beta.TargetSearchFilter filters = 3;
   */
  filters: TargetSearchFilter[];
};

/**
 * @generated from message zitadel.action.v2beta.ListTargetsRequest
 */
export declare type ListTargetsRequestJson = {
  /**
   * List limitations and ordering.
   *
   * @generated from field: optional zitadel.filter.v2beta.PaginationRequest pagination = 1;
   */
  pagination?: PaginationRequestJson;

  /**
   * The field the result is sorted by. The default is the creation date. Beware that if you change this, your result pagination might be inconsistent.
   *
   * @generated from field: optional zitadel.action.v2beta.TargetFieldName sorting_column = 2;
   */
  sortingColumn?: TargetFieldNameJson;

  /**
   * Define the criteria to query for.
   *
   * @generated from field: repeated zitadel.action.v2beta.TargetSearchFilter filters = 3;
   */
  filters?: TargetSearchFilterJson[];
};

/**
 * Describes the message zitadel.action.v2beta.ListTargetsRequest.
 * Use `create(ListTargetsRequestSchema)` to create a new message.
 */
export declare const ListTargetsRequestSchema: GenMessage<ListTargetsRequest, {jsonType: ListTargetsRequestJson}>;

/**
 * @generated from message zitadel.action.v2beta.ListTargetsResponse
 */
export declare type ListTargetsResponse = Message<"zitadel.action.v2beta.ListTargetsResponse"> & {
  /**
   * @generated from field: zitadel.filter.v2beta.PaginationResponse pagination = 1;
   */
  pagination?: PaginationResponse;

  /**
   * @generated from field: repeated zitadel.action.v2beta.Target result = 2;
   */
  result: Target[];
};

/**
 * @generated from message zitadel.action.v2beta.ListTargetsResponse
 */
export declare type ListTargetsResponseJson = {
  /**
   * @generated from field: zitadel.filter.v2beta.PaginationResponse pagination = 1;
   */
  pagination?: PaginationResponseJson;

  /**
   * @generated from field: repeated zitadel.action.v2beta.Target result = 2;
   */
  result?: TargetJson[];
};

/**
 * Describes the message zitadel.action.v2beta.ListTargetsResponse.
 * Use `create(ListTargetsResponseSchema)` to create a new message.
 */
export declare const ListTargetsResponseSchema: GenMessage<ListTargetsResponse, {jsonType: ListTargetsResponseJson}>;

/**
 * @generated from message zitadel.action.v2beta.SetExecutionRequest
 */
export declare type SetExecutionRequest = Message<"zitadel.action.v2beta.SetExecutionRequest"> & {
  /**
   * Condition defining when the execution should be used.
   *
   * @generated from field: zitadel.action.v2beta.Condition condition = 1;
   */
  condition?: Condition;

  /**
   * Ordered list of targets called during the execution.
   *
   * @generated from field: repeated string targets = 2;
   */
  targets: string[];
};

/**
 * @generated from message zitadel.action.v2beta.SetExecutionRequest
 */
export declare type SetExecutionRequestJson = {
  /**
   * Condition defining when the execution should be used.
   *
   * @generated from field: zitadel.action.v2beta.Condition condition = 1;
   */
  condition?: ConditionJson;

  /**
   * Ordered list of targets called during the execution.
   *
   * @generated from field: repeated string targets = 2;
   */
  targets?: string[];
};

/**
 * Describes the message zitadel.action.v2beta.SetExecutionRequest.
 * Use `create(SetExecutionRequestSchema)` to create a new message.
 */
export declare const SetExecutionRequestSchema: GenMessage<SetExecutionRequest, {jsonType: SetExecutionRequestJson}>;

/**
 * @generated from message zitadel.action.v2beta.SetExecutionResponse
 */
export declare type SetExecutionResponse = Message<"zitadel.action.v2beta.SetExecutionResponse"> & {
  /**
   * The timestamp of the execution set.
   *
   * @generated from field: google.protobuf.Timestamp set_date = 1;
   */
  setDate?: Timestamp;
};

/**
 * @generated from message zitadel.action.v2beta.SetExecutionResponse
 */
export declare type SetExecutionResponseJson = {
  /**
   * The timestamp of the execution set.
   *
   * @generated from field: google.protobuf.Timestamp set_date = 1;
   */
  setDate?: TimestampJson;
};

/**
 * Describes the message zitadel.action.v2beta.SetExecutionResponse.
 * Use `create(SetExecutionResponseSchema)` to create a new message.
 */
export declare const SetExecutionResponseSchema: GenMessage<SetExecutionResponse, {jsonType: SetExecutionResponseJson}>;

/**
 * @generated from message zitadel.action.v2beta.ListExecutionsRequest
 */
export declare type ListExecutionsRequest = Message<"zitadel.action.v2beta.ListExecutionsRequest"> & {
  /**
   * List limitations and ordering.
   *
   * @generated from field: optional zitadel.filter.v2beta.PaginationRequest pagination = 1;
   */
  pagination?: PaginationRequest;

  /**
   * The field the result is sorted by. The default is the creation date. Beware that if you change this, your result pagination might be inconsistent.
   *
   * @generated from field: optional zitadel.action.v2beta.ExecutionFieldName sorting_column = 2;
   */
  sortingColumn?: ExecutionFieldName;

  /**
   * Define the criteria to query for.
   *
   * @generated from field: repeated zitadel.action.v2beta.ExecutionSearchFilter filters = 3;
   */
  filters: ExecutionSearchFilter[];
};

/**
 * @generated from message zitadel.action.v2beta.ListExecutionsRequest
 */
export declare type ListExecutionsRequestJson = {
  /**
   * List limitations and ordering.
   *
   * @generated from field: optional zitadel.filter.v2beta.PaginationRequest pagination = 1;
   */
  pagination?: PaginationRequestJson;

  /**
   * The field the result is sorted by. The default is the creation date. Beware that if you change this, your result pagination might be inconsistent.
   *
   * @generated from field: optional zitadel.action.v2beta.ExecutionFieldName sorting_column = 2;
   */
  sortingColumn?: ExecutionFieldNameJson;

  /**
   * Define the criteria to query for.
   *
   * @generated from field: repeated zitadel.action.v2beta.ExecutionSearchFilter filters = 3;
   */
  filters?: ExecutionSearchFilterJson[];
};

/**
 * Describes the message zitadel.action.v2beta.ListExecutionsRequest.
 * Use `create(ListExecutionsRequestSchema)` to create a new message.
 */
export declare const ListExecutionsRequestSchema: GenMessage<ListExecutionsRequest, {jsonType: ListExecutionsRequestJson}>;

/**
 * @generated from message zitadel.action.v2beta.ListExecutionsResponse
 */
export declare type ListExecutionsResponse = Message<"zitadel.action.v2beta.ListExecutionsResponse"> & {
  /**
   * @generated from field: zitadel.filter.v2beta.PaginationResponse pagination = 1;
   */
  pagination?: PaginationResponse;

  /**
   * @generated from field: repeated zitadel.action.v2beta.Execution result = 2;
   */
  result: Execution[];
};

/**
 * @generated from message zitadel.action.v2beta.ListExecutionsResponse
 */
export declare type ListExecutionsResponseJson = {
  /**
   * @generated from field: zitadel.filter.v2beta.PaginationResponse pagination = 1;
   */
  pagination?: PaginationResponseJson;

  /**
   * @generated from field: repeated zitadel.action.v2beta.Execution result = 2;
   */
  result?: ExecutionJson[];
};

/**
 * Describes the message zitadel.action.v2beta.ListExecutionsResponse.
 * Use `create(ListExecutionsResponseSchema)` to create a new message.
 */
export declare const ListExecutionsResponseSchema: GenMessage<ListExecutionsResponse, {jsonType: ListExecutionsResponseJson}>;

/**
 * @generated from message zitadel.action.v2beta.ListExecutionFunctionsRequest
 */
export declare type ListExecutionFunctionsRequest = Message<"zitadel.action.v2beta.ListExecutionFunctionsRequest"> & {
};

/**
 * @generated from message zitadel.action.v2beta.ListExecutionFunctionsRequest
 */
export declare type ListExecutionFunctionsRequestJson = {
};

/**
 * Describes the message zitadel.action.v2beta.ListExecutionFunctionsRequest.
 * Use `create(ListExecutionFunctionsRequestSchema)` to create a new message.
 */
export declare const ListExecutionFunctionsRequestSchema: GenMessage<ListExecutionFunctionsRequest, {jsonType: ListExecutionFunctionsRequestJson}>;

/**
 * @generated from message zitadel.action.v2beta.ListExecutionFunctionsResponse
 */
export declare type ListExecutionFunctionsResponse = Message<"zitadel.action.v2beta.ListExecutionFunctionsResponse"> & {
  /**
   * All available methods
   *
   * @generated from field: repeated string functions = 1;
   */
  functions: string[];
};

/**
 * @generated from message zitadel.action.v2beta.ListExecutionFunctionsResponse
 */
export declare type ListExecutionFunctionsResponseJson = {
  /**
   * All available methods
   *
   * @generated from field: repeated string functions = 1;
   */
  functions?: string[];
};

/**
 * Describes the message zitadel.action.v2beta.ListExecutionFunctionsResponse.
 * Use `create(ListExecutionFunctionsResponseSchema)` to create a new message.
 */
export declare const ListExecutionFunctionsResponseSchema: GenMessage<ListExecutionFunctionsResponse, {jsonType: ListExecutionFunctionsResponseJson}>;

/**
 * @generated from message zitadel.action.v2beta.ListExecutionMethodsRequest
 */
export declare type ListExecutionMethodsRequest = Message<"zitadel.action.v2beta.ListExecutionMethodsRequest"> & {
};

/**
 * @generated from message zitadel.action.v2beta.ListExecutionMethodsRequest
 */
export declare type ListExecutionMethodsRequestJson = {
};

/**
 * Describes the message zitadel.action.v2beta.ListExecutionMethodsRequest.
 * Use `create(ListExecutionMethodsRequestSchema)` to create a new message.
 */
export declare const ListExecutionMethodsRequestSchema: GenMessage<ListExecutionMethodsRequest, {jsonType: ListExecutionMethodsRequestJson}>;

/**
 * @generated from message zitadel.action.v2beta.ListExecutionMethodsResponse
 */
export declare type ListExecutionMethodsResponse = Message<"zitadel.action.v2beta.ListExecutionMethodsResponse"> & {
  /**
   * All available methods
   *
   * @generated from field: repeated string methods = 1;
   */
  methods: string[];
};

/**
 * @generated from message zitadel.action.v2beta.ListExecutionMethodsResponse
 */
export declare type ListExecutionMethodsResponseJson = {
  /**
   * All available methods
   *
   * @generated from field: repeated string methods = 1;
   */
  methods?: string[];
};

/**
 * Describes the message zitadel.action.v2beta.ListExecutionMethodsResponse.
 * Use `create(ListExecutionMethodsResponseSchema)` to create a new message.
 */
export declare const ListExecutionMethodsResponseSchema: GenMessage<ListExecutionMethodsResponse, {jsonType: ListExecutionMethodsResponseJson}>;

/**
 * @generated from message zitadel.action.v2beta.ListExecutionServicesRequest
 */
export declare type ListExecutionServicesRequest = Message<"zitadel.action.v2beta.ListExecutionServicesRequest"> & {
};

/**
 * @generated from message zitadel.action.v2beta.ListExecutionServicesRequest
 */
export declare type ListExecutionServicesRequestJson = {
};

/**
 * Describes the message zitadel.action.v2beta.ListExecutionServicesRequest.
 * Use `create(ListExecutionServicesRequestSchema)` to create a new message.
 */
export declare const ListExecutionServicesRequestSchema: GenMessage<ListExecutionServicesRequest, {jsonType: ListExecutionServicesRequestJson}>;

/**
 * @generated from message zitadel.action.v2beta.ListExecutionServicesResponse
 */
export declare type ListExecutionServicesResponse = Message<"zitadel.action.v2beta.ListExecutionServicesResponse"> & {
  /**
   * All available methods
   *
   * @generated from field: repeated string services = 1;
   */
  services: string[];
};

/**
 * @generated from message zitadel.action.v2beta.ListExecutionServicesResponse
 */
export declare type ListExecutionServicesResponseJson = {
  /**
   * All available methods
   *
   * @generated from field: repeated string services = 1;
   */
  services?: string[];
};

/**
 * Describes the message zitadel.action.v2beta.ListExecutionServicesResponse.
 * Use `create(ListExecutionServicesResponseSchema)` to create a new message.
 */
export declare const ListExecutionServicesResponseSchema: GenMessage<ListExecutionServicesResponse, {jsonType: ListExecutionServicesResponseJson}>;

/**
 * Service to manage custom executions.
 * The service provides methods to create, update, delete and list targets and executions.
 *
 * @generated from service zitadel.action.v2beta.ActionService
 */
export declare const ActionService: GenService<{
  /**
   * Create Target
   *
   * Create a new target to your endpoint, which can be used in executions.
   *
   * Required permission:
   *   - `action.target.write`
   *
   * Required feature flag:
   *   - `actions`
   *
   * @generated from rpc zitadel.action.v2beta.ActionService.CreateTarget
   */
  createTarget: {
    methodKind: "unary";
    input: typeof CreateTargetRequestSchema;
    output: typeof CreateTargetResponseSchema;
  },
  /**
   * Update Target
   *
   * Update an existing target.
   * To generate a new signing key set the optional expirationSigningKey.
   *
   * Required permission:
   *   - `action.target.write`
   *
   * Required feature flag:
   *   - `actions`
   *
   * @generated from rpc zitadel.action.v2beta.ActionService.UpdateTarget
   */
  updateTarget: {
    methodKind: "unary";
    input: typeof UpdateTargetRequestSchema;
    output: typeof UpdateTargetResponseSchema;
  },
  /**
   * Delete Target
   *
   * Delete an existing target. This will remove it from any configured execution as well.
   * In case the target is not found, the request will return a successful response as
   * the desired state is already achieved.
   *
   * Required permission:
   *   - `action.target.delete`
   *
   * Required feature flag:
   *   - `actions`
   *
   * @generated from rpc zitadel.action.v2beta.ActionService.DeleteTarget
   */
  deleteTarget: {
    methodKind: "unary";
    input: typeof DeleteTargetRequestSchema;
    output: typeof DeleteTargetResponseSchema;
  },
  /**
   * Get Target
   *
   * Returns the target identified by the requested ID.
   *
   * Required permission:
   *   - `action.target.read`
   *
   * Required feature flag:
   *   - `actions`
   *
   * @generated from rpc zitadel.action.v2beta.ActionService.GetTarget
   */
  getTarget: {
    methodKind: "unary";
    input: typeof GetTargetRequestSchema;
    output: typeof GetTargetResponseSchema;
  },
  /**
   * List targets
   *
   * List all matching targets. By default all targets of the instance are returned.
   * Make sure to include a limit and sorting for pagination.
   *
   * Required permission:
   *   - `action.target.read`
   *
   * Required feature flag:
   *   - `actions`
   *
   * @generated from rpc zitadel.action.v2beta.ActionService.ListTargets
   */
  listTargets: {
    methodKind: "unary";
    input: typeof ListTargetsRequestSchema;
    output: typeof ListTargetsResponseSchema;
  },
  /**
   * Set Execution
   *
   * Sets an execution to call a target or include the targets of another execution.
   * Setting an empty list of targets will remove all targets from the execution, making it a noop.
   *
   * Required permission:
   *   - `action.execution.write`
   *
   * Required feature flag:
   *   - `actions`
   *
   * @generated from rpc zitadel.action.v2beta.ActionService.SetExecution
   */
  setExecution: {
    methodKind: "unary";
    input: typeof SetExecutionRequestSchema;
    output: typeof SetExecutionResponseSchema;
  },
  /**
   * List Executions
   *
   * List all matching executions. By default all executions of the instance are returned that have at least one execution target.
   * Make sure to include a limit and sorting for pagination.
   *
   * Required permission:
   *   - `action.execution.read`
   *
   * Required feature flag:
   *   - `actions`
   *
   * @generated from rpc zitadel.action.v2beta.ActionService.ListExecutions
   */
  listExecutions: {
    methodKind: "unary";
    input: typeof ListExecutionsRequestSchema;
    output: typeof ListExecutionsResponseSchema;
  },
  /**
   * List Execution Functions
   *
   * List all available functions which can be used as condition for executions.
   *
   * @generated from rpc zitadel.action.v2beta.ActionService.ListExecutionFunctions
   */
  listExecutionFunctions: {
    methodKind: "unary";
    input: typeof ListExecutionFunctionsRequestSchema;
    output: typeof ListExecutionFunctionsResponseSchema;
  },
  /**
   * List Execution Methods
   *
   * List all available methods which can be used as condition for executions.
   *
   * @generated from rpc zitadel.action.v2beta.ActionService.ListExecutionMethods
   */
  listExecutionMethods: {
    methodKind: "unary";
    input: typeof ListExecutionMethodsRequestSchema;
    output: typeof ListExecutionMethodsResponseSchema;
  },
  /**
   * List Execution Services
   *
   * List all available services which can be used as condition for executions.
   *
   * @generated from rpc zitadel.action.v2beta.ActionService.ListExecutionServices
   */
  listExecutionServices: {
    methodKind: "unary";
    input: typeof ListExecutionServicesRequestSchema;
    output: typeof ListExecutionServicesResponseSchema;
  },
}>;

